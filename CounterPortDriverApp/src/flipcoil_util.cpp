//flipcoil_util.cpp

#include "flipcoil_util.h"
#include "flipcoil.h"


void FlipCoilDriver::multimeterTask(void)
{
  
  
  //blmeasbl measurement

  printf("\n\nMultimeter task");
  //vector<float> coil_samples;
  double variable;

  vector<float> coil_samples;
  double prev = -3;
  int x = 0;

  getDoubleParam(P_FlipCoil, &prev);
  getDoubleParam(P_FlipCoil, &variable);
  while (prev * variable > 0)
  {
    prev = variable;
    getDoubleParam(P_FlipCoil, &variable);
  }
  //As soon as we break this loop we're finding the bits we're trying to integrate 
  vector<float> pos_samples;
  vector<float> neg_samples;
  int crossings = 0;
  const char* buffer = "RMEM 1, 0\r\n";
  int test;
  size_t nBytesOut, nBytesIn;
  int eomReason;
  while (crossings < 3)
  {
    test = pasynOctetSyncIO->writeRead(pasynUserPort, buffer, strlen(buffer), cmdBuffer, 256, 5.0, &nBytesOut, &nBytesIn, &eomReason);
    
    if (nBytesIn > 0)
    {
      char* token = strtok(cmdBuffer, "\r\n");
      float prev = stof(token);
      while (token != NULL)
      {
        float variable = stof(token);
        if (variable * prev < 0)
        {
          crossings += 1;
        }
        if (crossings == 3)
        {
          printf("\n\nGot the sine wave\n\n");
          break;
        }
        if(variable < 0)
        {
          neg_samples.push_back(-1 * variable);
        }
        else 
        {
          pos_samples.push_back(variable);
        }
        prev = variable;
        token = strtok(NULL, "\r\n");

      }
    }
  }
  //Then the time integral is calculated within coil_samples coilintpeak
  float pos_peak = coilIntPeak(COIL_DELTA, pos_samples);
  
  //Third a a time integral of the negative samples is calculated coilintpeak
  float neg_peak = -1 * coilIntPeak(COIL_DELTA, neg_samples);
  
  //Check for forward and reverse half cycles, takes results from coilintpeak 
  //TODO Figure out why this if statement is necessary
  printf("Calculated Pos Peak: %f Calculated Neg Peak: %f\n\n", pos_peak, neg_peak);
  /**
  if (neg_peak * pos_peak >= 0)
  {
   printf("Problems, didn't receive coil voltages most likely");
    throw runtime_error("Neg_peak * pos_peak returned a positive number or was zero, should be impossible");
  }
  **/
  if (pos_peak > 0 )
  {
    vt_pos_mult.push_back(pos_peak);
    vt_neg_mult.push_back(neg_peak);
  }
  else 
  {
    vt_neg_mult.push_back(pos_peak);
    vt_pos_mult.push_back(neg_peak);
  }
  vt_avg_mult.push_back((vt_pos_mult.back() - vt_neg_mult.back()) / 2);
  //printf("Integrated calculation, %g\n", vt_avg[i]);
  //Finding the mean of integrated voltage values
  float sum = 0;
  for(float x : vt_avg_mult)
  {
    sum += x;
  }

  //TODO Pass this by reference? or make the task return this, im not sure what it's used for
  float avg = sum / vt_avg_mult.size();
  Avg_Int_Mult.store(avg);
  printf("\n\n\nAveraged integral %g", avg);
  //Finding standard deviation
  sum = 0;
  for(float x : vt_avg_mult)
  {
    sum += pow((x - avg), 2);
  }
  float std_dev = sqrt(sum / NUM_MEASUREMENTS);
}

/**
 * @brief Isolates a the first peak value in a sine wave or similar function
 * modifies passed in start end and peak values to correspond with
 * zero crossing points and the found peak value.
 * 
 * @param start Variable to store the index of the first encountered zero crossing before the peak
 * @param end   Variable to store the index of the first zero crossing after the peak
 * @param peak  Variable to store the index of the found peak value 
 * @param samples Vector that contains the wave data we search through to find start end and peak indices
 */
void peakIsolator(int& start, int& end, int& peak, vector<float> samples)
{
  int total_samples = samples.size();
  peak = -1;
  end = -1;
  start = -1;
  //Find peak
  for(int i = 1; i < total_samples; i++)
  {
    if(samples[i] > samples[peak])
    {
      peak = i;
    }
  }
  start = 0;
  for(int j = peak; j >= 1; j--)
  {
    if(samples[j-1] <= 0 && samples[j] >= 0 )
    {
      start = j -1;
      break;
    }
  }

  for(int k = peak; k < total_samples-1; k++)
  {
    if(samples[k] >= 0 && samples[k+1] <= 0)
    {
      end = k+1;
      break;
    }
  }
}
/**
 * @brief calculates an integral of the voltage generated by the rotating coil 
 *
 * @param coil_delta time between voltage samples
 * @param voltage_samples sampled voltages
 * @return Calculated integral of the voltage 
 */
float coilIntPeak(float coil_delta, vector<float> voltage_samples)
{

  //So the original way was a little bit weird
  //Just going to do a full trapezoid rule for the entire hting
  //Rather than mix and match 3 different integrals
  //printf("\n\n\n\n\n");
  float to_ret = 0;
  for(int i = 0; i < voltage_samples.size(); i++)
  {
    if(voltage_samples[i] < 0)
    {
      continue;
    }
    if(i == 0 || i == voltage_samples.size() - 1)
    {
      to_ret += voltage_samples[i];

    }
    else
    {
      to_ret += 2*voltage_samples[i];
    }

  }
  //printf("\n\n\n\n\n\n");
  
  return (coil_delta / 2) * to_ret;
}

void sineWaveTester(vector<float>& coil_samples)
{
  //Do something in here that inserts a sine wave at some point
  const float pi = 3.1415926535;
  const int amplitude = 1;
  const float offset = 2 * pi / 10;
  for(int i = 0; i < COIL_SAMPLES; i++)
  {
    coil_samples.push_back(amplitude * sin(2 * pi * i / COIL_SAMPLES + offset));
  }
}
